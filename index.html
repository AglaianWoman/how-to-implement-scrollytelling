<!doctype html>
<html lang="en">
<head>
	<title>Scrollytelling - The Pudding</title>

	<!-- <meta property="hide-footer-social", content="true"> -->
	<!-- <meta property="hide-footer-recirc", content="true">
	<meta property="hide-footer-newsletter", content="true">
	<meta property="hide-footer-company", content="true"> -->


	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="description" content="">
	<meta name="news_keywords" content="">


	<meta property="og:title" content="">
	<meta property="og:site_name" content="The Pudding">
	<meta property="og:url" content="">
	<meta property="og:description" content="">
	<meta property="og:type" content="article">
	<meta property="og:locale" content="en_US">

	<meta property="og:image" content="">
	<meta property="og:image:type" content="image/jpeg">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="600">

	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="https://pudding.cool">
	<meta name="twitter:creator" content="@pudding">
	<meta name="twitter:title" content="">
	<meta name="twitter:description" content="">
	<meta name="twitter:image:src" content="">
	  
	<link rel="stylesheet" type="text/css" href="https://cloud.typography.com/7124072/6351572/css/fonts.css" />

	<link rel='stylesheet' href='css/style.css' />
	<link rel='stylesheet' href='css/graphic.css' />
	<link rel='stylesheet' href='css/prism.css' />
</head>
<body>
	<main>
		<div class='intro'>
			<p>
				<strong>Scrollytelling is the best</strong> (or the worst depending on your <a target='_blank' href='https://eagereyes.org/blog/2016/the-scrollytelling-scourge'>point of view</a>). We mostly love it here at <a href'#'>The Pudding</a>. But creating a scroll-driven story is hardly a standardize practice, and there are many libraries out there that can help make it happen.
			</p>
			<p>Just to be clear, scrollytelling is when content (eg. a graphic) is revealed or changes as the user scrolls. It does not affect scroll behavior, but simply monitors it. As Martha Stewart would say, it's a good thing. Do not confuse this will scroll-jacking, which manipulates the browser's scroll mechanics with JavaScript, and is generally evil.
			</p> 
			<p>
				<strong>In this post, I look at how to tackle a simple scroll-driven chart using six different libraries</strong>, and discuss the pros and cons of each implementation. It is inspired by Lisa Charlotte Rost's <a target='_blank' href='https://lisacharlotterost.github.io/2016/05/17/one-chart-code/'>great post</a> about how to make the same chart using 12 different charting libraries. 
			</p>
			<p>
				I'm not going to get into the different types of scrollytelling, or debate the serious ethical and moral implications of the practice. I defer to <a target='_blank' href='https://medium.com/@zanarmstrong/why-choose-scrollytelling-steppers-155a59dd97fe'>these</a> <a target='_blank' href='http://vallandingham.me/scroll_talk/examples/'>posts</a> for scrollytelling primers.
			</p>
			<p>
				We have two goals here:
			<p>
			<ol>
				<li>
					1. Using the "scroll-to-trigger" pattern, each trigger element (in our case a block of text) tells the chart to update to a new state.
				</li>
				<li>	
					2. We want the chart to stay fixed when we while the text moves, and have it snap back into place as it enters and exits.
				</li>
			</ol>
			<p> It should look something like this:</p>
			<p>[GIF here]</p>
			<p class='disclaimer'>
				Disclaimer: <em>this post does not cover responsive solutions (though you should do it, and most libraries make it pretty painless), so if you had the audacity to resize your browser, refresh the page. I'm not going to cover mobile either, which will probably become its own post soon enough...</em>
			</p>
		</div>


		<div class='library library__waypoints'>
			<h2 class='library__hed'>#1 - <a href='#'>Waypoints</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'>Waypoints is a very solid choice. It has been around for a while, and supports both vanilla JS and jQuery integration. It has an easy to understand API and good documentation. It has a good debug extension to reduce some head-scratching, and some nice add-ons for stuff like inview detection and sticky elements.</p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
function waypoints() {
	var selector = '.library__waypoints'
	var containerEl = document.querySelector(selector)
	var graphicEl = containerEl.querySelector('.graphic')
	var graphicVisEl = containerEl.querySelector('.graphic__vis')
	var triggerEls = containerEl.querySelectorAll('.trigger')

	var rightOffset = graphicEl.getBoundingClientRect().left + 'px'
	var graphic = createGraphic(selector)
	
	for (var i = 0; i < triggerEls.length; i++) {
		new Waypoint({
			element: triggerEls[i],
			handler: function(direction) {
				var step = +this.element.getAttribute('data-step')
				var nextStep = direction === 'down' ? step : Math.max(0, step - 1)

				graphic.update(nextStep)
			},
			offset: '50%',
		})
	}

	var toggle = function(fixed, bottom) {
		if (fixed) {
			graphicVisEl.classList.add('is-fixed')
			graphicVisEl.style.right = rightOffset
		} else {
			graphicVisEl.classList.remove('is-fixed')
			graphicVisEl.style.right = 0
		}
		
		if (bottom) graphicVisEl.classList.add('is-bottom')
		else graphicVisEl.classList.remove('is-bottom')
	}

	var enterWaypoint = new Waypoint({
		element: containerEl,
		handler: function(direction) {
			var fixed = direction === 'down'
			var bottom = false
			toggle(fixed, bottom)
		},
	})

	var exitWaypoint = new Waypoint({
		element: containerEl,
		handler: function(direction) {
			var fixed = direction === 'up'
			var bottom = !fixed
			toggle(fixed, bottom)
		},
		offset: 'bottom-in-view',
	})
}
				</code></pre>
			</div>
		</div>
		
		<div class='library library__scrollmagic'>
			<h2 class='library__hed'>#2 - <a href='#'>ScrollMagic</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'></p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
				</code></pre>
			</div>
		</div>

		<div class='library library__graphscroll'>
			<h2 class='library__hed'>#3 - <a href='#'>graph-scroll.js</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'>Couldn't use without tweaking library to accept offset customization (link to PR).</p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
				</code></pre>
			</div>
		</div>

		<div class='library library__inview'>
			<h2 class='library__hed'>#4 - <a href='#'>in-view.js</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'>Couldn't use without exporting singleton (link to Gabriel's version).</p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
				</code></pre>
			</div>
		</div>

		<div class='library library__scrollstory'>
			<h2 class='library__hed'>#5 - <a href='#'>ScrollStory</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'>Manually calculate enter/exit on scroll</p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
				</code></pre>
			</div>
		</div>


		<div class='outro'>
			<p>Outro</p>
		</div>
	</main>

	<script src='js/libs/d3.v4.min.js'></script>
	<script src='js/prism.js'></script>
	

	<!-- The scroll libraries -->
	
	<!-- http://imakewebthings.com/waypoints/ -->
	<script src='js/libs/noframework.waypoints.min.js'></script>
	
	<!-- http://scrollmagic.io/ -->
	<script src='js/libs/ScrollMagic.min.js'></script>

	<!-- https://1wheel.github.io/graph-scroll/ -->
	<script src='js/libs/graph-scroll.js'></script>

	<!-- https://camwiegert.github.io/in-view/ -->
	<script src='js/libs/in-view.min.js'></script>

	<!-- https://github.com/sjwilliams/scrollstory -->
	<script src='js/libs/jquery-3.1.1.min.js'></script>
	<script src='js/libs/jquery.scrollstory.min.js'></script>

	<!-- http://bl.ocks.org/tonyhschu/raw/af64df46f7b5b760fc1db1260dd6ec6a/ -->

	
	<!-- The code to scroll the story -->
	<script src='js/entry.js'></script>
	<!-- <script src="https://pudding.cool/assets/scripts/pudding-footer.js"></script> -->
	<script id="__bs_script__">//<![CDATA[
	    document.write("<script async src='http://HOST:3000/browser-sync/browser-sync-client.js?v=2.17.5'><\/script>".replace("HOST", location.hostname));
	//]]></script>

</body>
</html>
