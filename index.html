<!doctype html>
<html lang="en">
<head>
	<title>Scrollytelling - The Pudding</title>
	
	<!-- <meta property="hide-footer-social", content="true"> -->
	<!-- <meta property="hide-footer-recirc", content="true">
	<meta property="hide-footer-newsletter", content="true">
	<meta property="hide-footer-company", content="true"> -->


	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="description" content="">
	<meta name="news_keywords" content="">
	
	
	<meta property="og:title" content="">
	  <meta property="og:site_name" content="The Pudding">
	  <meta property="og:url" content="">
	  <meta property="og:description" content="">
	  <meta property="og:type" content="article">
	  <meta property="og:locale" content="en_US">
	
	  <meta property="og:image" content="">
	  <meta property="og:image:type" content="image/jpeg">
	  <meta property="og:image:width" content="1200">
	  <meta property="og:image:height" content="600">
	
	  <meta name="twitter:card" content="summary_large_image">
	  <meta name="twitter:site" content="https://pudding.cool">
	  <meta name="twitter:creator" content="@pudding">
	  <meta name="twitter:title" content="">
	  <meta name="twitter:description" content="">
	  <meta name="twitter:image:src" content="">		
	<link rel='stylesheet' href='css/style.css' />
	<link rel='stylesheet' href='css/graphic.css' />
	<link rel='stylesheet' href='css/prism.css' />
</head>
<body>
	<main>
		<div class='intro'>
			<p>
				<strong>Scrollytelling is the best</strong> (or the worst depending on your point of view). We mostly love it here at <a href'#'>The Pudding</a>. But creating a scroll-driven story is hardly a standardize practice, and there are many libraries out there that can help make it happen.
			</p>
			<p>
				<strong>In this post, I look at how to tackle a simple scroll-driven chart using six different libraries</strong>, and discuss the pros and cons of each implementation. It is inspired by Lisa Charlotte Rost's <a target='_blank' href='https://lisacharlotterost.github.io/2016/05/17/one-chart-code/'>great post</a> about how to make the same chart using 12 different charting libraries. 
			</p>
			<p>
				I'm not going to get into the different types of scrollytelling, or debate the serious ethical and moral implications of the practice. I defer to <a target='_blank' href='https://medium.com/@zanarmstrong/why-choose-scrollytelling-steppers-155a59dd97fe'>these</a> <a target='_blank' href='http://vallandingham.me/scroll_talk/examples/'>posts</a> for scrollytelling primers.
			</p>
			<p>
				We are going to use the "scroll-to-trigger" pattern, where each trigger element (in this case a block of text) tells the chart to update to a new state. Additionally, we want the chart to stay fixed while the text moves, and have it snap back into place as it enters and exits. It should look something like this: [GIF HERE]
			<p>
			<p>
				Disclaimer: <em>this post does not cover responsive solutions (though you should do it, and most libraries make it pretty painless), so if you had the audacity to resize your browser, refresh the page. I'm not going to cover mobile stuff here, which will probably become its own post soon enough...</em>
			</p>
		</div>
		<div class='library library__waypoints'>
			<h2 class='library__hed'>#1 - <a href='#'>Waypoints</a></h2>
			<div class='library__graphic graphic'>
				<div class='graphic__prose'>
					<p class='trigger' data-step='0'>Step 1 in the graphic. It triggers in the middle of the viewport. For this graphic, step 1 is the same as the initial view so the reader doesn't miss anything.</p>
					<p class='trigger' data-step='1'>Step 2 arrives. The graphic should be locking into a fixed position right about now. We could have a whole bunch of these "fixed" steps.</p>
					<p class='trigger' data-step='2'>Step 3 concludes our brief tour. The graphic should now go back to its original in-flow position, elegantly falling back into place.</p>
				</div>
				<div class='graphic__vis'></div>
			</div>
			<div class='library__results'>
				<p class='results_graf'>Overall, waypoints is a very solid choice. It has been around for a while, and supports both vanilla JS and jQuery integration. It has an easy to understand API and good documentation. It also a nice a debug extension to reduce some head-scratching. And some nice add-ons for stuff like inview detection, and sticky elements.</p>
				<!-- <div class='results__pros-cons'>
					<div class='pros-cons pros'>
						<p class='pros-cons__hed'>Pros</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
					<div class='pros-cons cons'>
						<p class='pros-cons__hed'>Cons</p>
						<ul class='pros-cons__list'>
							<li>Thing 1</li>
						</ul>
					</div>
				</div> -->
			</div>
			<div class='library__code'>
				<pre><code class='language-js'>
function waypoints() {
	var selector = '.library__waypoints'
	var containerEl = document.querySelector(selector)
	var graphicEl = containerEl.querySelector('.graphic')
	var graphicVisEl = containerEl.querySelector('.graphic__vis')
	var triggerEls = containerEl.querySelectorAll('.trigger')

	var rightOffset = graphicEl.getBoundingClientRect().left + 'px'
	var graphic = createGraphic(selector)
	
	for (var i = 0; i < triggerEls.length; i++) {
		new Waypoint({
			element: triggerEls[i],
			handler: function(direction) {
				var step = +this.element.getAttribute('data-step')
				var nextStep = direction === 'down' ? step : Math.max(0, step - 1)

				graphic.update(nextStep)
			},
			offset: '50%',
		})
	}

	var toggle = function(fixed, bottom) {
		if (fixed) {
			graphicVisEl.classList.add('is-fixed')
			graphicVisEl.style.right = rightOffset
		} else {
			graphicVisEl.classList.remove('is-fixed')
			graphicVisEl.style.right = 0
		}
		
		if (bottom) graphicVisEl.classList.add('is-bottom')
		else graphicVisEl.classList.remove('is-bottom')
	}

	var enterWaypoint = new Waypoint({
		element: containerEl,
		handler: function(direction) {
			var fixed = direction === 'down'
			var bottom = false
			toggle(fixed, bottom)
		},
	})

	var exitWaypoint = new Waypoint({
		element: containerEl,
		handler: function(direction) {
			var fixed = direction === 'up'
			var bottom = !fixed
			toggle(fixed, bottom)
		},
		offset: 'bottom-in-view',
	})
}
				</code></pre>
			</div>
		</div>
		<div class='outro'>
			<p>Outro</p>
		</div>
	</main>

	<script src='js/libs/d3.v4.min.js'></script>

	

	<!-- The scroll libraries -->
	
	<!-- https://terwanerik.github.io/ScrollTrigger/ -->
	<script src='js/libs/ScrollTrigger.min.js'></script>

	<!-- http://imakewebthings.com/waypoints/ -->
	<script src='js/libs/noframework.waypoints.min.js'></script>
	
	<!-- https://1wheel.github.io/graph-scroll/ -->
	<script src='js/libs/graph-scroll.js'></script>

	<!-- http://scrollmagic.io/ -->
	<script src='js/libs/ScrollMagic.min.js'></script>

	<!-- https://github.com/sjwilliams/scrollstory -->
	<script src='js/libs/jquery-3.1.1.min.js'></script>
	<script src='js/libs/jquery.scrollstory.min.js'></script>

	<!-- https://camwiegert.github.io/in-view/ -->
	<script src='js/libs/in-view.min.js'></script>

	<!-- http://bl.ocks.org/tonyhschu/raw/af64df46f7b5b760fc1db1260dd6ec6a/ -->

	
	<!-- The code to scroll the story -->
	<script src='js/entry.js'></script>
	<script src='js/prism.js'></script>
	<!-- <script src="https://pudding.cool/assets/scripts/pudding-footer.js"></script> -->
	<script id="__bs_script__">//<![CDATA[
	    document.write("<script async src='http://HOST:3000/browser-sync/browser-sync-client.js?v=2.17.5'><\/script>".replace("HOST", location.hostname));
	//]]></script>

</body>
</html>
